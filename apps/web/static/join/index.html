<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Join Session - Gigwidget</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .container {
      text-align: center;
      padding: 2rem;
      max-width: 400px;
      width: 100%;
    }
    .logo {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }
    h1 { font-size: 1.5rem; margin-bottom: 1.5rem; font-weight: 500; }
    .status {
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1rem;
    }
    .status-text { font-size: 0.9rem; color: #aaa; margin-bottom: 0.75rem; }
    .progress-bar {
      height: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 0.5rem;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #e94560 0%, #ff6b8a 100%);
      width: 0%;
      transition: width 0.3s ease;
    }
    .progress-text { font-size: 0.8rem; color: #888; }
    .host-info {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
      color: #aaa;
      font-size: 0.9rem;
    }
    .error {
      background: rgba(233, 69, 96, 0.2);
      border: 1px solid #e94560;
      border-radius: 8px;
      padding: 1rem;
      margin-top: 1rem;
    }
    .error h3 { color: #e94560; margin-bottom: 0.5rem; }
    .retry-btn {
      background: #e94560;
      color: #fff;
      border: none;
      padding: 0.75rem 2rem;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      margin-top: 1rem;
    }
    .retry-btn:hover { background: #ff6b8a; }
    .songs-preview {
      text-align: left;
      margin-top: 1rem;
      max-height: 200px;
      overflow-y: auto;
    }
    .songs-preview h4 { font-size: 0.8rem; color: #888; margin-bottom: 0.5rem; }
    .song-item {
      font-size: 0.85rem;
      padding: 0.25rem 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .hidden { display: none; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .connecting .status-text { animation: pulse 1.5s ease-in-out infinite; }
  </style>
</head>
<body>
  <div class="container">
    <div class="logo">Gigwidget</div>
    <h1 id="title">Joining Session...</h1>

    <div id="host-info" class="host-info hidden">
      Connecting to <span id="host-name"></span>
    </div>

    <div id="status" class="status connecting">
      <div class="status-text" id="status-text">Establishing connection...</div>
      <div class="progress-bar"><div class="progress-fill" id="progress"></div></div>
      <div class="progress-text" id="progress-text">0%</div>
    </div>

    <div id="songs-preview" class="songs-preview hidden">
      <h4>Songs in this session:</h4>
      <div id="songs-list"></div>
    </div>

    <div id="error" class="error hidden">
      <h3>Connection Failed</h3>
      <p id="error-text"></p>
      <button class="retry-btn" onclick="location.reload()">Try Again</button>
    </div>
  </div>

<script>
(function() {
  'use strict';

  // Constants
  const SIGNALING_SERVERS = [
    'wss://signaling.yjs.dev',
    'wss://y-webrtc-signaling-eu.herokuapp.com'
  ];
  const BOOTSTRAP_CHANNEL = 'gigwidget-bootstrap';
  const CHUNK_SIZE = 16 * 1024;

  // State
  let payload = null;
  let peerConnection = null;
  let dataChannel = null;
  let signalingWs = null;
  let currentTransfer = null;

  // UI Elements
  const $ = id => document.getElementById(id);

  // Parse session data from URL hash
  function parseSessionData() {
    const hash = location.hash.slice(1);
    if (!hash) throw new Error('No session data in URL');

    try {
      const compact = JSON.parse(atob(hash));
      return {
        sessionId: compact.s,
        type: compact.t,
        hostId: compact.h,
        hostName: compact.n,
        connectionInfo: decodeConnectionInfo(compact.t, compact.c),
        libraryManifest: (compact.m || []).map(e => ({
          id: e.i,
          title: e.t,
          artist: e.a
        })),
        createdAt: compact.ts,
        expiresAt: compact.ex,
        bootstrapVersion: compact.bv,
        bundleHash: compact.bh,
        bundleSize: compact.bs,
        songDataSize: compact.ss
      };
    } catch (e) {
      throw new Error('Invalid session data');
    }
  }

  function decodeConnectionInfo(type, c) {
    if (type === 'webrtc') {
      return { type: 'webrtc', signalingServer: c.s, roomId: c.r, password: c.p };
    }
    throw new Error('Only WebRTC is supported for bootstrap');
  }

  function updateUI(status, progress = 0, text = '') {
    $('status').className = 'status ' + status;
    $('status-text').textContent = text || getStatusText(status);
    $('progress').style.width = progress + '%';
    $('progress-text').textContent = Math.round(progress) + '%';
  }

  function getStatusText(status) {
    switch(status) {
      case 'connecting': return 'Establishing connection...';
      case 'connected': return 'Connected! Requesting data...';
      case 'downloading-app': return 'Downloading app...';
      case 'downloading-songs': return 'Downloading songs...';
      case 'loading': return 'Loading app...';
      default: return status;
    }
  }

  function showError(msg) {
    $('error').classList.remove('hidden');
    $('error-text').textContent = msg;
    $('status').classList.add('hidden');
  }

  function showSongs(manifest) {
    if (!manifest || manifest.length === 0) return;

    $('songs-preview').classList.remove('hidden');
    $('songs-list').innerHTML = manifest.map(s =>
      `<div class="song-item">${s.title}${s.artist ? ' - ' + s.artist : ''}</div>`
    ).join('');
  }

  // WebRTC signaling
  async function connectSignaling() {
    const info = payload.connectionInfo;
    const server = info.signalingServer || SIGNALING_SERVERS[0];

    return new Promise((resolve, reject) => {
      signalingWs = new WebSocket(server);

      signalingWs.onopen = () => {
        // Subscribe to the room
        signalingWs.send(JSON.stringify({
          type: 'subscribe',
          topics: [payload.sessionId]
        }));
        resolve();
      };

      signalingWs.onmessage = async (event) => {
        const msg = JSON.parse(event.data);

        if (msg.type === 'publish') {
          const data = msg.data || JSON.parse(msg.message || '{}');
          await handleSignalingMessage(data, msg.from);
        }
      };

      signalingWs.onerror = () => reject(new Error('Signaling connection failed'));
      signalingWs.onclose = () => {};
    });
  }

  async function handleSignalingMessage(msg, from) {
    if (msg.type === 'offer' && !peerConnection) {
      // Create peer connection and answer
      await createPeerConnection();
      await peerConnection.setRemoteDescription(msg.sdp);
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);

      sendSignaling({ type: 'answer', sdp: peerConnection.localDescription }, from);
    }
    else if (msg.type === 'answer' && peerConnection) {
      await peerConnection.setRemoteDescription(msg.sdp);
    }
    else if (msg.type === 'ice' && peerConnection) {
      await peerConnection.addIceCandidate(msg.candidate);
    }
  }

  function sendSignaling(data, to) {
    signalingWs.send(JSON.stringify({
      type: 'publish',
      topic: payload.sessionId,
      data: data,
      to: to
    }));
  }

  // WebRTC peer connection
  async function createPeerConnection() {
    peerConnection = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });

    peerConnection.onicecandidate = (e) => {
      if (e.candidate) {
        sendSignaling({ type: 'ice', candidate: e.candidate });
      }
    };

    peerConnection.ondatachannel = (e) => {
      if (e.channel.label === BOOTSTRAP_CHANNEL) {
        setupDataChannel(e.channel);
      }
    };

    peerConnection.onconnectionstatechange = () => {
      if (peerConnection.connectionState === 'connected') {
        updateUI('connected');
      } else if (peerConnection.connectionState === 'failed') {
        showError('Connection to host failed');
      }
    };

    // Create bootstrap data channel
    dataChannel = peerConnection.createDataChannel(BOOTSTRAP_CHANNEL, { ordered: true });
    setupDataChannel(dataChannel);

    // Create and send offer
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    sendSignaling({ type: 'offer', sdp: peerConnection.localDescription });
  }

  function setupDataChannel(channel) {
    dataChannel = channel;
    channel.binaryType = 'arraybuffer';

    channel.onopen = () => {
      updateUI('connected', 5);
      // Request app bundle
      channel.send(JSON.stringify({ type: 'request-bootstrap', version: 'latest' }));
    };

    channel.onmessage = (e) => handleDataChannelMessage(e.data);
    channel.onerror = () => showError('Data channel error');
  }

  // Transfer handling
  function handleDataChannelMessage(data) {
    if (typeof data === 'string') {
      const msg = JSON.parse(data);
      handleControlMessage(msg);
    } else {
      // Binary chunk
      handleChunk(data);
    }
  }

  function handleControlMessage(msg) {
    switch(msg.type) {
      case 'transfer-start':
        currentTransfer = {
          id: msg.transferId,
          type: msg.contentType,
          totalSize: msg.totalSize,
          totalChunks: msg.totalChunks,
          hash: msg.hash,
          compression: msg.compression,
          chunks: [],
          received: 0
        };
        updateUI(msg.contentType === 'app-bundle' ? 'downloading-app' : 'downloading-songs', 5);
        break;

      case 'transfer-end':
        if (msg.success && currentTransfer) {
          completeTransfer();
        }
        break;

      case 'error':
        showError(msg.message || 'Transfer failed');
        break;
    }
  }

  function handleChunk(data) {
    if (!currentTransfer) return;

    currentTransfer.chunks.push(data);
    currentTransfer.received++;

    const progress = 5 + (currentTransfer.received / currentTransfer.totalChunks) * 45;
    updateUI(
      currentTransfer.type === 'app-bundle' ? 'downloading-app' : 'downloading-songs',
      progress,
      `Downloading ${currentTransfer.type === 'app-bundle' ? 'app' : 'songs'}... ${currentTransfer.received}/${currentTransfer.totalChunks}`
    );
  }

  async function completeTransfer() {
    const transfer = currentTransfer;
    currentTransfer = null;

    // Reassemble chunks
    const totalSize = transfer.chunks.reduce((s, c) => s + c.byteLength, 0);
    const data = new Uint8Array(totalSize);
    let offset = 0;
    for (const chunk of transfer.chunks) {
      data.set(new Uint8Array(chunk), offset);
      offset += chunk.byteLength;
    }

    // Verify hash
    const hash = await computeHash(data.buffer);
    if (hash !== transfer.hash) {
      showError('Data integrity check failed');
      return;
    }

    if (transfer.type === 'app-bundle') {
      // Store app bundle and request songs
      window.__GIGWIDGET_BOOTSTRAP_CONTEXT__ = window.__GIGWIDGET_BOOTSTRAP_CONTEXT__ || {};
      window.__GIGWIDGET_BOOTSTRAP_CONTEXT__.appBundle = data.buffer;
      window.__GIGWIDGET_BOOTSTRAP_CONTEXT__.compression = transfer.compression;
      window.__GIGWIDGET_BOOTSTRAP_CONTEXT__.payload = payload;
      window.__GIGWIDGET_BOOTSTRAP_CONTEXT__.dataChannel = dataChannel;
      window.__GIGWIDGET_BOOTSTRAP_CONTEXT__.peerConnection = peerConnection;

      // Request song data
      updateUI('downloading-songs', 50);
      dataChannel.send(JSON.stringify({ type: 'request-songs' }));
    }
    else if (transfer.type === 'song-data') {
      // Store song data and inject app
      window.__GIGWIDGET_BOOTSTRAP_CONTEXT__.songData = data.buffer;
      updateUI('loading', 95);
      await injectApp();
    }
  }

  async function computeHash(data) {
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }

  async function injectApp() {
    const ctx = window.__GIGWIDGET_BOOTSTRAP_CONTEXT__;

    try {
      // Decompress if needed
      let appCode;
      if (ctx.compression === 'gzip') {
        const ds = new DecompressionStream('gzip');
        const writer = ds.writable.getWriter();
        const reader = ds.readable.getReader();
        writer.write(ctx.appBundle);
        writer.close();

        const chunks = [];
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          chunks.push(value);
        }

        const size = chunks.reduce((s, c) => s + c.length, 0);
        const decompressed = new Uint8Array(size);
        let off = 0;
        for (const c of chunks) {
          decompressed.set(c, off);
          off += c.length;
        }
        appCode = new TextDecoder().decode(decompressed);
      } else {
        appCode = new TextDecoder().decode(ctx.appBundle);
      }

      // Mark bootstrap as complete
      ctx.bootstrapComplete = true;

      // Replace document with app
      document.open();
      document.write(appCode);
      document.close();
    } catch (e) {
      showError('Failed to load app: ' + e.message);
    }
  }

  // Initialize
  async function init() {
    try {
      payload = parseSessionData();

      // Check expiry
      if (payload.expiresAt && Date.now() > payload.expiresAt) {
        showError('This session has expired');
        return;
      }

      // Show host info
      $('host-name').textContent = payload.hostName;
      $('host-info').classList.remove('hidden');

      // Show songs preview
      showSongs(payload.libraryManifest);

      // Connect
      updateUI('connecting', 0);
      await connectSignaling();
      await createPeerConnection();

    } catch (e) {
      showError(e.message || 'Failed to join session');
    }
  }

  init();
})();
</script>
</body>
</html>
