{"version":3,"file":"C6md0y2C.js","sources":["../../../../../../../../node_modules/.pnpm/lib0@0.2.117/node_modules/lib0/indexeddb.js","../../../../../../../../node_modules/.pnpm/y-indexeddb@9.0.12_yjs@13.6.29/node_modules/y-indexeddb/src/y-indexeddb.js"],"sourcesContent":["/* eslint-env browser */\n\n/**\n * Helpers to work with IndexedDB.\n *\n * @module indexeddb\n */\n\nimport * as promise from './promise.js'\nimport * as error from './error.js'\n\n/* c8 ignore start */\n\n/**\n * IDB Request to Promise transformer\n *\n * @param {IDBRequest} request\n * @return {Promise<any>}\n */\nexport const rtop = request => promise.create((resolve, reject) => {\n  // @ts-ignore\n  request.onerror = event => reject(new Error(event.target.error))\n  // @ts-ignore\n  request.onsuccess = event => resolve(event.target.result)\n})\n\n/**\n * @param {string} name\n * @param {function(IDBDatabase):any} initDB Called when the database is first created\n * @return {Promise<IDBDatabase>}\n */\nexport const openDB = (name, initDB) => promise.create((resolve, reject) => {\n  const request = indexedDB.open(name)\n  /**\n   * @param {any} event\n   */\n  request.onupgradeneeded = event => initDB(event.target.result)\n  /**\n   * @param {any} event\n   */\n  request.onerror = event => reject(error.create(event.target.error))\n  /**\n   * @param {any} event\n   */\n  request.onsuccess = event => {\n    /**\n     * @type {IDBDatabase}\n     */\n    const db = event.target.result\n    db.onversionchange = () => { db.close() }\n    resolve(db)\n  }\n})\n\n/**\n * @param {string} name\n */\nexport const deleteDB = name => rtop(indexedDB.deleteDatabase(name))\n\n/**\n * @param {IDBDatabase} db\n * @param {Array<Array<string>|Array<string|IDBObjectStoreParameters|undefined>>} definitions\n */\nexport const createStores = (db, definitions) => definitions.forEach(d =>\n  // @ts-ignore\n  db.createObjectStore.apply(db, d)\n)\n\n/**\n * @param {IDBDatabase} db\n * @param {Array<string>} stores\n * @param {\"readwrite\"|\"readonly\"} [access]\n * @return {Array<IDBObjectStore>}\n */\nexport const transact = (db, stores, access = 'readwrite') => {\n  const transaction = db.transaction(stores, access)\n  return stores.map(store => getStore(transaction, store))\n}\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<number>}\n */\nexport const count = (store, range) =>\n  rtop(store.count(range))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | Array<any> } key\n * @return {Promise<String | number | ArrayBuffer | Date | Array<any>>}\n */\nexport const get = (store, key) =>\n  rtop(store.get(key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | IDBKeyRange | Array<any> } key\n */\nexport const del = (store, key) =>\n  rtop(store.delete(key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | boolean} item\n * @param {String | number | ArrayBuffer | Date | Array<any>} [key]\n */\nexport const put = (store, item, key) =>\n  rtop(store.put(item, key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | boolean}  item\n * @param {String | number | ArrayBuffer | Date | Array<any>}  key\n * @return {Promise<any>}\n */\nexport const add = (store, item, key) =>\n  rtop(store.add(item, key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date}  item\n * @return {Promise<number>} Returns the generated key\n */\nexport const addAutoKey = (store, item) =>\n  rtop(store.add(item))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @param {number} [limit]\n * @return {Promise<Array<any>>}\n */\nexport const getAll = (store, range, limit) =>\n  rtop(store.getAll(range, limit))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @param {number} [limit]\n * @return {Promise<Array<any>>}\n */\nexport const getAllKeys = (store, range, limit) =>\n  rtop(store.getAllKeys(range, limit))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} query\n * @param {'next'|'prev'|'nextunique'|'prevunique'} direction\n * @return {Promise<any>}\n */\nexport const queryFirst = (store, query, direction) => {\n  /**\n   * @type {any}\n   */\n  let first = null\n  return iterateKeys(store, query, key => {\n    first = key\n    return false\n  }, direction).then(() => first)\n}\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange?} [range]\n * @return {Promise<any>}\n */\nexport const getLastKey = (store, range = null) => queryFirst(store, range, 'prev')\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange?} [range]\n * @return {Promise<any>}\n */\nexport const getFirstKey = (store, range = null) => queryFirst(store, range, 'next')\n\n/**\n * @typedef KeyValuePair\n * @type {Object}\n * @property {any} k key\n * @property {any} v Value\n */\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @param {number} [limit]\n * @return {Promise<Array<KeyValuePair>>}\n */\nexport const getAllKeysValues = (store, range, limit) =>\n  // @ts-ignore\n  promise.all([getAllKeys(store, range, limit), getAll(store, range, limit)]).then(([ks, vs]) => ks.map((k, i) => ({ k, v: vs[i] })))\n\n/**\n * @param {any} request\n * @param {function(IDBCursorWithValue):void|boolean|Promise<void|boolean>} f\n * @return {Promise<void>}\n */\nconst iterateOnRequest = (request, f) => promise.create((resolve, reject) => {\n  request.onerror = reject\n  /**\n   * @param {any} event\n   */\n  request.onsuccess = async event => {\n    const cursor = event.target.result\n    if (cursor === null || (await f(cursor)) === false) {\n      return resolve()\n    }\n    cursor.continue()\n  }\n})\n\n/**\n * Iterate on keys and values\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} keyrange\n * @param {function(any,any):void|boolean|Promise<void|boolean>} f Callback that receives (value, key)\n * @param {'next'|'prev'|'nextunique'|'prevunique'} direction\n */\nexport const iterate = (store, keyrange, f, direction = 'next') =>\n  iterateOnRequest(store.openCursor(keyrange, direction), cursor => f(cursor.value, cursor.key))\n\n/**\n * Iterate on the keys (no values)\n *\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} keyrange\n * @param {function(any):void|boolean|Promise<void|boolean>} f callback that receives the key\n * @param {'next'|'prev'|'nextunique'|'prevunique'} direction\n */\nexport const iterateKeys = (store, keyrange, f, direction = 'next') =>\n  iterateOnRequest(store.openKeyCursor(keyrange, direction), cursor => f(cursor.key))\n\n/**\n * Open store from transaction\n * @param {IDBTransaction} t\n * @param {String} store\n * @returns {IDBObjectStore}\n */\nexport const getStore = (t, store) => t.objectStore(store)\n\n/**\n * @param {any} lower\n * @param {any} upper\n * @param {boolean} lowerOpen\n * @param {boolean} upperOpen\n */\nexport const createIDBKeyRangeBound = (lower, upper, lowerOpen, upperOpen) => IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen)\n\n/**\n * @param {any} upper\n * @param {boolean} upperOpen\n */\nexport const createIDBKeyRangeUpperBound = (upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen)\n\n/**\n * @param {any} lower\n * @param {boolean} lowerOpen\n */\nexport const createIDBKeyRangeLowerBound = (lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen)\n\n/* c8 ignore stop */\n","import * as Y from 'yjs'\nimport * as idb from 'lib0/indexeddb'\nimport * as promise from 'lib0/promise'\nimport { Observable } from 'lib0/observable'\n\nconst customStoreName = 'custom'\nconst updatesStoreName = 'updates'\n\nexport const PREFERRED_TRIM_SIZE = 500\n\n/**\n * @param {IndexeddbPersistence} idbPersistence\n * @param {function(IDBObjectStore):void} [beforeApplyUpdatesCallback]\n * @param {function(IDBObjectStore):void} [afterApplyUpdatesCallback]\n */\nexport const fetchUpdates = (idbPersistence, beforeApplyUpdatesCallback = () => {}, afterApplyUpdatesCallback = () => {}) => {\n  const [updatesStore] = idb.transact(/** @type {IDBDatabase} */ (idbPersistence.db), [updatesStoreName]) // , 'readonly')\n  return idb.getAll(updatesStore, idb.createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then(updates => {\n    if (!idbPersistence._destroyed) {\n      beforeApplyUpdatesCallback(updatesStore)\n      Y.transact(idbPersistence.doc, () => {\n        updates.forEach(val => Y.applyUpdate(idbPersistence.doc, val))\n      }, idbPersistence, false)\n      afterApplyUpdatesCallback(updatesStore)\n    }\n  })\n    .then(() => idb.getLastKey(updatesStore).then(lastKey => { idbPersistence._dbref = lastKey + 1 }))\n    .then(() => idb.count(updatesStore).then(cnt => { idbPersistence._dbsize = cnt }))\n    .then(() => updatesStore)\n}\n\n/**\n * @param {IndexeddbPersistence} idbPersistence\n * @param {boolean} forceStore\n */\nexport const storeState = (idbPersistence, forceStore = true) =>\n  fetchUpdates(idbPersistence)\n    .then(updatesStore => {\n      if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {\n        idb.addAutoKey(updatesStore, Y.encodeStateAsUpdate(idbPersistence.doc))\n          .then(() => idb.del(updatesStore, idb.createIDBKeyRangeUpperBound(idbPersistence._dbref, true)))\n          .then(() => idb.count(updatesStore).then(cnt => { idbPersistence._dbsize = cnt }))\n      }\n    })\n\n/**\n * @param {string} name\n */\nexport const clearDocument = name => idb.deleteDB(name)\n\n/**\n * @extends Observable<string>\n */\nexport class IndexeddbPersistence extends Observable {\n  /**\n   * @param {string} name\n   * @param {Y.Doc} doc\n   */\n  constructor (name, doc) {\n    super()\n    this.doc = doc\n    this.name = name\n    this._dbref = 0\n    this._dbsize = 0\n    this._destroyed = false\n    /**\n     * @type {IDBDatabase|null}\n     */\n    this.db = null\n    this.synced = false\n    this._db = idb.openDB(name, db =>\n      idb.createStores(db, [\n        ['updates', { autoIncrement: true }],\n        ['custom']\n      ])\n    )\n    /**\n     * @type {Promise<IndexeddbPersistence>}\n     */\n    this.whenSynced = promise.create(resolve => this.on('synced', () => resolve(this)))\n\n    this._db.then(db => {\n      this.db = db\n      /**\n       * @param {IDBObjectStore} updatesStore\n       */\n      const beforeApplyUpdatesCallback = (updatesStore) => idb.addAutoKey(updatesStore, Y.encodeStateAsUpdate(doc))\n      const afterApplyUpdatesCallback = () => {\n        if (this._destroyed) return this\n        this.synced = true\n        this.emit('synced', [this])\n      }\n      fetchUpdates(this, beforeApplyUpdatesCallback, afterApplyUpdatesCallback)\n    })\n    /**\n     * Timeout in ms untill data is merged and persisted in idb.\n     */\n    this._storeTimeout = 1000\n    /**\n     * @type {any}\n     */\n    this._storeTimeoutId = null\n    /**\n     * @param {Uint8Array} update\n     * @param {any} origin\n     */\n    this._storeUpdate = (update, origin) => {\n      if (this.db && origin !== this) {\n        const [updatesStore] = idb.transact(/** @type {IDBDatabase} */ (this.db), [updatesStoreName])\n        idb.addAutoKey(updatesStore, update)\n        if (++this._dbsize >= PREFERRED_TRIM_SIZE) {\n          // debounce store call\n          if (this._storeTimeoutId !== null) {\n            clearTimeout(this._storeTimeoutId)\n          }\n          this._storeTimeoutId = setTimeout(() => {\n            storeState(this, false)\n            this._storeTimeoutId = null\n          }, this._storeTimeout)\n        }\n      }\n    }\n    doc.on('update', this._storeUpdate)\n    this.destroy = this.destroy.bind(this)\n    doc.on('destroy', this.destroy)\n  }\n\n  destroy () {\n    if (this._storeTimeoutId) {\n      clearTimeout(this._storeTimeoutId)\n    }\n    this.doc.off('update', this._storeUpdate)\n    this.doc.off('destroy', this.destroy)\n    this._destroyed = true\n    return this._db.then(db => {\n      db.close()\n    })\n  }\n\n  /**\n   * Destroys this instance and removes all data from indexeddb.\n   *\n   * @return {Promise<void>}\n   */\n  clearData () {\n    return this.destroy().then(() => {\n      idb.deleteDB(this.name)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @return {Promise<String | number | ArrayBuffer | Date | any>}\n   */\n  get (key) {\n    return this._db.then(db => {\n      const [custom] = idb.transact(db, [customStoreName], 'readonly')\n      return idb.get(custom, key)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @param {String | number | ArrayBuffer | Date} value\n   * @return {Promise<String | number | ArrayBuffer | Date>}\n   */\n  set (key, value) {\n    return this._db.then(db => {\n      const [custom] = idb.transact(db, [customStoreName])\n      return idb.put(custom, value, key)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @return {Promise<undefined>}\n   */\n  del (key) {\n    return this._db.then(db => {\n      const [custom] = idb.transact(db, [customStoreName])\n      return idb.del(custom, key)\n    })\n  }\n}\n"],"names":["rtop","request","promise.create","resolve","reject","event","openDB","name","initDB","error.create","db","deleteDB","createStores","definitions","d","transact","stores","access","transaction","store","getStore","count","range","get","key","del","put","item","addAutoKey","getAll","limit","queryFirst","query","direction","first","iterateKeys","getLastKey","iterateOnRequest","f","cursor","keyrange","createIDBKeyRangeUpperBound","upper","upperOpen","createIDBKeyRangeLowerBound","lower","lowerOpen","customStoreName","updatesStoreName","PREFERRED_TRIM_SIZE","fetchUpdates","idbPersistence","beforeApplyUpdatesCallback","afterApplyUpdatesCallback","updatesStore","idb.transact","idb.getAll","idb.createIDBKeyRangeLowerBound","updates","Y.transact","val","Y.applyUpdate","idb.getLastKey","lastKey","idb.count","cnt","storeState","forceStore","idb.addAutoKey","Y.encodeStateAsUpdate","idb.del","idb.createIDBKeyRangeUpperBound","IndexeddbPersistence","Observable","doc","idb.openDB","idb.createStores","update","origin","idb.deleteDB","custom","idb.get","value","idb.put"],"mappings":"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","x_google_ignoreList":[0,1]}